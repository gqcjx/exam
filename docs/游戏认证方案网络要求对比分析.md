# 大嘴鸟游戏认证方案网络要求对比分析

## 📊 三种方案对比

### 方案A：iframe 共享 session

**实现方式：**
- 游戏嵌入在主应用的 iframe 中
- 通过 postMessage 或直接访问父窗口获取 session

**网络连接要求：**
- ✅ **最低**：如果游戏 HTML 在同一域名下，几乎不需要额外网络请求
- ❌ **需要**：iframe 加载需要加载主应用的完整页面
- ❌ **需要**：如果不同源，需要 postMessage 通信开销

**优点：**
- 直接共享 session，无需传递 token
- 安全性最高（token 不暴露）
- 网络请求最少（游戏在同一域名下时）

**缺点：**
- iframe 可能被浏览器限制（X-Frame-Options）
- 需要处理跨域问题
- 游戏代码需要修改为 iframe 兼容模式
- 性能开销（双重页面渲染）

**适用场景：**
- 游戏和主应用在同一域名
- 需要最高安全性
- 可以接受 iframe 的性能开销

---

### 方案B：URL 参数传递 token（当前方案）

**实现方式：**
- 游戏独立运行
- Token 通过 URL 参数传递

**网络连接要求：**
- ⚠️ **中等**：
  1. **必需**：动态导入 Supabase 客户端库 (`https://esm.sh/@supabase/supabase-js@2`) - **1次网络请求**
  2. **必需**：验证 token (`auth.getUser()`) - **1次网络请求**
  3. **必需**：游戏结束时保存分数 - **1次网络请求**

**优点：**
- 实现简单，代码改动少
- 游戏完全独立，易于维护
- 无需处理跨域问题

**缺点：**
- Token 暴露在 URL 中（可能被记录在浏览器历史、服务器日志中）
- 需要 3 次网络请求（导入库、验证、保存）
- 如果网络不稳定，初始化可能失败

**当前代码中的网络请求：**
```javascript
// 1. 动态导入（必需，网络请求）
const { createClient } = await import('https://esm.sh/@supabase/supabase-js@2');

// 2. 验证 token（必需，网络请求）
const { data: { user }, error } = await supabaseClient.auth.getUser();

// 3. 保存分数（游戏结束时，网络请求）
await supabaseClient.from('game_scores').upsert(...);
```

---

### 方案C：localStorage 存储 session（推荐 ⭐）

**实现方式：**
- 游戏独立运行
- Session 信息存储在 localStorage
- 游戏从 localStorage 读取 token

**网络连接要求：**
- ✅ **最低**：
  1. **可选**：静态包含 Supabase 客户端库（构建时打包，无网络请求）
  2. **可跳过**：无需验证 token（直接使用，让保存分数时验证）
  3. **必需**：游戏结束时保存分数 - **仅1次网络请求**

**优点：**
- ✅ **网络请求最少**：理论上只需要保存分数时的 1 次网络请求
- ✅ **更安全**：Token 不在 URL 中，不会泄露到日志
- ✅ **更稳定**：不依赖动态导入，即使网络不稳定也能启动游戏
- ✅ **离线友好**：游戏可以完全离线运行，只在保存时才需要网络

**缺点：**
- 需要修改代码，主应用需要将 session 写入 localStorage
- 需要处理 token 过期的情况（但保存时会自然验证）

**优化后的实现：**
```javascript
// 1. localStorage 读取（本地操作，无网络请求）
const token = localStorage.getItem('supabase_auth_token');
const supabaseUrl = localStorage.getItem('supabase_url');
const supabaseKey = localStorage.getItem('supabase_anon_key');

// 2. 跳过验证（让保存分数时再验证）
// 直接使用 token 创建客户端

// 3. 保存分数时验证（游戏结束时，仅1次网络请求）
await supabaseClient.from('game_scores').upsert(...);
```

---

## 🎯 推荐方案：方案C（localStorage）

### 为什么方案C网络要求最少？

1. **零初始化网络请求**
   - localStorage 读取是本地操作（0ms）
   - 可以静态包含 Supabase 库（构建时打包，无运行时网络请求）
   - 跳过 token 验证（减少 1 次网络请求）

2. **延迟验证策略**
   - 不在初始化时验证 token
   - 在保存分数时自然验证（如果 token 失效，保存会失败，但不影响游戏运行）

3. **离线优先**
   - 游戏可以完全离线运行
   - 只在最后保存时才需要网络连接
   - 即使保存失败，游戏仍可正常运行

### 网络请求对比表

| 方案 | 初始化请求 | 验证请求 | 保存请求 | 总计 |
|------|-----------|---------|---------|------|
| A (iframe) | 0-1* | 0 | 1 | **1-2** |
| B (URL参数) | 1 (导入库) | 1 (验证) | 1 | **3** |
| C (localStorage) | 0 | 0** | 1 | **1** |

*iframe 需要加载父页面（如果同源则为 0）  
**延迟验证，在保存时验证

### 实施建议

如果网络环境不稳定，建议采用**方案C**，原因：

1. ✅ **最少网络请求**：只需保存分数时的 1 次请求
2. ✅ **更稳定**：游戏启动不依赖网络
3. ✅ **更安全**：Token 不在 URL 中
4. ✅ **用户体验好**：即使网络有问题，游戏也能正常运行

### 方案C 实施要点

1. **主应用写入 localStorage**
   ```javascript
   // 在 GameDazui.tsx 中
   localStorage.setItem('supabase_auth_token', session.access_token);
   localStorage.setItem('supabase_url', supabaseUrl);
   localStorage.setItem('supabase_anon_key', supabaseKey);
   ```

2. **游戏读取 localStorage**
   ```javascript
   // 在 dazui/app.js 中
   const token = localStorage.getItem('supabase_auth_token');
   const supabaseUrl = localStorage.getItem('supabase_url');
   const supabaseKey = localStorage.getItem('supabase_anon_key');
   ```

3. **可选：静态包含 Supabase 库**
   - 将 Supabase 客户端库作为依赖项安装
   - 构建时打包，避免运行时动态导入

4. **延迟验证**
   - 不调用 `auth.getUser()` 验证
   - 直接使用 token 创建客户端
   - 保存分数时如果 token 失效，会自然失败（可以提示用户重新登录）
